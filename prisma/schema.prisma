generator client {
  provider        = "prisma-client-js"
  previewFeatures = ["postgresqlExtensions"]
}

datasource db {
  provider   = "postgresql"
  url        = env("DATABASE_URL")
  extensions = [postgis]
}

model AdminConfig {
  id        String   @id @default(cuid())
  orgId     String   @unique @default("default")
  config    Json     @db.JsonB
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("admin_configs")
}

model Source {
  id               String     @id @default(cuid())
  name             String
  baseUrl          String
  type             String // portal, broker, county, enrichment
  adapter          String
  enabled          Boolean    @default(true)
  crawlFrequency   String     @default("weekly")
  rateLimitPerMin  Int        @default(6)
  lastCrawledAt    DateTime?
  metadata         Json?      @db.JsonB
  createdAt        DateTime   @default(now())
  updatedAt        DateTime   @updatedAt
  
  listings         Listing[]
  scanRuns         ScanRunSource[]

  @@map("sources")
}

model ScanRun {
  id               String          @id @default(cuid())
  runType          String          // weekly, on-demand
  status           String          @default("pending") // pending, running, completed, failed
  startedAt        DateTime        @default(now())
  completedAt      DateTime?
  processedCount   Int             @default(0)
  newCount         Int             @default(0)
  updatedCount     Int             @default(0)
  duplicateCount   Int             @default(0)
  errorCount       Int             @default(0)
  errors           Json?           @db.JsonB
  metadata         Json?           @db.JsonB
  createdAt        DateTime        @default(now())
  
  sources          ScanRunSource[]

  @@map("scan_runs")
}

model ScanRunSource {
  id          String   @id @default(cuid())
  scanRunId   String
  sourceId    String
  status      String   @default("pending")
  processed   Int      @default(0)
  errors      Json?    @db.JsonB
  createdAt   DateTime @default(now())
  
  scanRun     ScanRun  @relation(fields: [scanRunId], references: [id])
  source      Source   @relation(fields: [sourceId], references: [id])

  @@unique([scanRunId, sourceId])
  @@map("scan_run_sources")
}

model Parcel {
  id               String          @id @default(cuid())
  apn              String?
  acreage          Float
  geometry         Json?           @db.JsonB // GeoJSON geometry
  centroidLat      Float?
  centroidLon      Float?
  county           String
  countyFips       String?
  state            String
  address          String?
  zoning           String?
  zoningBucket     String?         // ag, timber, ruralRes, mixedUse, conservation
  taxValue         Float?
  taxYear          Int?
  landUseCode      String?
  metadata         Json?           @db.JsonB
  createdAt        DateTime        @default(now())
  updatedAt        DateTime        @updatedAt
  
  listings         Listing[]
  ownership        Ownership?
  features         Features?
  fitScore         FitScore?
  deals            Deal[]
  
  @@unique([apn, county, state])
  @@index([centroidLat, centroidLon])
  @@index([county, state])
  @@map("parcels")
}

model Listing {
  id               String          @id @default(cuid())
  sourceId         String
  parcelId         String?
  externalId       String?         // Source's listing ID
  url              String
  title            String
  description      String?
  price            Float?
  pricePerAcre     Float?
  status           String          @default("listed") // listed, off-market, distressed, sold
  photos           Json?           @db.JsonB // Array of photo URLs
  sourceData       Json?           @db.JsonB // Raw data from source
  firstSeenAt      DateTime        @default(now())
  lastSeenAt       DateTime        @default(now())
  lastChangedAt    DateTime?
  changeHistory    Json?           @db.JsonB
  createdAt        DateTime        @default(now())
  updatedAt        DateTime        @updatedAt
  
  source           Source          @relation(fields: [sourceId], references: [id])
  parcel           Parcel?         @relation(fields: [parcelId], references: [id])
  
  @@unique([sourceId, externalId])
  @@index([parcelId])
  @@index([status])
  @@map("listings")
}

model Ownership {
  id               String          @id @default(cuid())
  parcelId         String          @unique
  ownerName        String?
  ownerType        String?         // individual, LLC, corp, trust, government
  mailingAddress   String?
  mailingCity      String?
  mailingState     String?
  mailingZip       String?
  phone            String?
  email            String?
  acquisitionDate  DateTime?
  acquisitionPrice Float?
  metadata         Json?           @db.JsonB
  createdAt        DateTime        @default(now())
  updatedAt        DateTime        @updatedAt
  
  parcel           Parcel          @relation(fields: [parcelId], references: [id])
  
  @@map("ownerships")
}

model Features {
  id                String          @id @default(cuid())
  parcelId          String          @unique
  landCoverMix      Json?           @db.JsonB // {forest: %, pasture: %, crop: %, etc}
  slopeStats        Json?           @db.JsonB // {min, max, mean, percentOver20, percentOver40}
  elevationStats    Json?           @db.JsonB // {min, max, mean}
  soilsClass        String?
  soilsQuality      Int?            // 1-10 rating
  waterPresence     Boolean         @default(false)
  waterFeatures     String[]        // creek, pond, lake, river, wetland
  floodZone         String?
  inFloodway        Boolean         @default(false)
  wetlandsPercent   Float?
  roadFrontage      Float?          // feet
  roadAccess        String?         // paved, gravel, dirt, none
  powerDistance     Float?          // miles
  fiberDistance     Float?          // miles
  waterDistance     Float?          // miles to municipal water
  sewerDistance     Float?          // miles to sewer
  gasDistance       Float?          // miles to natural gas
  easements         String[]        // conservation, utility, access, etc
  improvementsValue Float?
  improvements      String[]        // house, barn, fence, etc
  metroDistance     Float?          // miles to nearest metro
  nearestMetro      String?
  airportDistance   Float?          // miles
  nearestAirport    String?
  metadata          Json?           @db.JsonB
  createdAt         DateTime        @default(now())
  updatedAt         DateTime        @updatedAt
  
  parcel            Parcel          @relation(fields: [parcelId], references: [id])
  
  @@map("features")
}

model FitScore {
  id                String          @id @default(cuid())
  parcelId          String          @unique
  overallScore      Int             // 0-100
  scoreBreakdown    Json            @db.JsonB // {acreage: 20, landCover: 15, etc}
  topReasons        String[]        // Top 5 contributing factors
  autoFailed        Boolean         @default(false)
  autoFailReason    String?
  scoreVersion      String          @default("1.0")
  computedAt        DateTime        @default(now())
  metadata          Json?           @db.JsonB
  createdAt         DateTime        @default(now())
  updatedAt         DateTime        @updatedAt
  
  parcel            Parcel          @relation(fields: [parcelId], references: [id])
  
  @@index([overallScore])
  @@map("fit_scores")
}

model Deal {
  id                String          @id @default(cuid())
  parcelId          String
  stage             String          @default("New") // New, Qualified, Triage, Pursuit, LOI, UC, Closed, Lost
  priority          String?         // P0, P1, P2, P3
  assignedTo        String?         // User ID from Clerk
  ownerContact      Json?           @db.JsonB
  lastContactDate   DateTime?
  nextActionDate    DateTime?
  nextAction        String?
  notes             String?
  internalNotes     String?
  metadata          Json?           @db.JsonB
  createdAt         DateTime        @default(now())
  updatedAt         DateTime        @updatedAt
  
  parcel            Parcel          @relation(fields: [parcelId], references: [id])
  activities        Activity[]
  
  @@index([stage])
  @@index([assignedTo])
  @@map("deals")
}

model Activity {
  id                String          @id @default(cuid())
  dealId            String
  userId            String          // User ID from Clerk
  type              String          // note, email, call, meeting, status_change
  description       String
  metadata          Json?           @db.JsonB
  createdAt         DateTime        @default(now())
  
  deal              Deal            @relation(fields: [dealId], references: [id])
  
  @@map("activities")
}

model SavedSearch {
  id                String          @id @default(cuid())
  userId            String          // User ID from Clerk
  name              String
  criteria          Json            @db.JsonB
  schedule          String?         // weekly, daily, manual
  lastRunAt         DateTime?
  emailNotification Boolean         @default(false)
  active            Boolean         @default(true)
  metadata          Json?           @db.JsonB
  createdAt         DateTime        @default(now())
  updatedAt         DateTime        @updatedAt
  
  @@index([userId])
  @@map("saved_searches")
}